# Chapter 2. 추상화 계층

## 널값 및 의사코드 규약

- null 이라는 값은 유용하지만 문제가 많은 양면이 존재
  - 값이 제공되지 않거나 함수가 원하는 결과를 반환할 수 없는 경우가 자주 발생하기 때문에 `값이 없다` 또는 `부재한다`는 개념은 유용
  - `값이 null 일 수 있거나 / null 이면 안되는 경우`가 항상 명백한 것은 아니라서 문제가 발생  
    - 개발자들은 변수에 액세스하기 전에 null 값인지 확인하는 것을 자주 잊어버린다.
- null 안전성 (null safety) 혹은 보이드 안전성(void safety) 에 대한 생각이 점점 추진력을 얻고 있다.
  - null 값이 가능한 변수나 반환값을 그에 맞게 표시
  - 컴파일러는 반드시 null 값 여부를 확인할 수 밖에 없도록 만듬
  - java 에는 `Optional<T>` 이 존재
  - null 안전성은 데이터 유형 이름 끝에 `?` 기호가 붙어 있으면 널 값을 가질 수 있다는 의미이다 ex) `Type?`

## 왜 추상화 계층을 만드는가?

- 어떤 문제를 하위 문제로 계속해서 나누어 내려가면서 추상화 계층을 만든다면, 같은 층위 내에서는 쉽게 이해할 수 있는 개념만을 다루기 때문에 개별 코드는 복잡해 보이지 않는다.
- 서버에 메시지를 보내야 한다는 상위 수준의 문제가 존재
- 상위 수준의 문제를 해결하기 위한 하위 문제가 많다.

- 서버에 메시지를 보낸다는 문제를 해결하기 위해 코드레벨에서는 다음과 같은 개념만 다루면 된다
  - 서버의 URL
  - 연결
  - 메시지 문자열 보내기
  - 연결 닫기
- 하위 문제를 살펴보면 HTTP 프로토콜을 살펴봐야 한다.
  - 전송할 수 있는 형식으로 문자열 직렬화
  - HTTP 프로토콜의 모든 복잡한 동작
  - TCP 연결
  - 사용자의 장치가 와이파이 혹은 셀룰러 네트워크에 연결되어 있는지 여부 확인
  - 데이터를 라디오 신호로 변조
  - 데이터 전송 오류 및 수정
- HTTP 연결은 이미 다른 개발자에 의해 추상화된 계층으로 만들어져 세부사항을 모르고도 서버에 메시지를 보낼 수 있다.
- 복잡한 문제라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로써 복잡한 문제를 쉽게 다룰 수 있다.

#### 추상화 계층 및 코드 품질의 핵심 요소
걔끗하고 뚜렷한 추상화 계층을 구축하면 아래 네 가지 핵심 요소를 달성할 수 있다. 
- 가독성
  - 깨끗하고 뚜렷한 추상화 계층을 만드는 것은 개발자가 한 번에 한두 개 정도의 계층과 몇 개의 개념만 다루면 된다는 것을 의미
- 모듈화
  - 추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장할 때
  - 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 쉬워진다
- 재사용성 및 일반화성
  - 하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기가 쉬워진다.
  - 문제가 적절하게 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 크다.
- 테스트 용이성
  - 하위 문제들을 깔끔하게 분리했으므로 작은 범위의 테스트가 가능하다
  - 따라서 테스트가 훨씬 쉬워진다

## 코드의 계층

- 추상화 계층을 생성하는 방법은 코드를 서로 다른 단위로 분할하여 단위 간의 의존 관계를 보여주는 의존성 그래프를 생성하는 것
- 프로그래밍 언어에서 코드를 다른 단위로 나누기 위한 언어 요소
  - 함수
  - 클래스
  - 인터페이스
  - 패키지, 네임스페이스, 모듈

#### API 및 구현 세부 사항

코드를 작성할 때 고려해야 할 측면 두 가지
- 코드를 호출할 때 볼 수 있는 내용
  - 퍼블릭 클래스, 인터페이스 및 함수
  - 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념
  - 코드 호출 시 코드를 올바르게 사용하기 위해 알아야 하는 추가 정보(ex. 호출 순서)
- 코드를 호출할 때 볼 수 없는 내용
  - 구현 세부 사항
- 작성한 코드들이 다른 코드들에 의해 사용될 수 있도록 미니 **API를 노출** 하는 것으로 생각해보자
  - 실제로 개발자들은 클래스, 인터페이스, 함수들을 `API 노출`이라고 말하곤 한다.
  - 코드를 API의 관점에서 생각하면 추상화 계층을 명확하게 만드는데 도움됨

#### 함수

- 각 함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적임
  - 문장으로 읽었을 때 너무 길거나 문장이 이해되지 않으면 더 작은 함수로 나누는 것이 유익할 것이다.
- 단순한 문장으로 표현되는 함수를 작성하기 위한 좋은 전략
  - 단일 업무 수행
    - `단일 업무` 라는 것은 해석하기 나름
  - 잘 명명된 다른 함수를 호출해서 더 복잡할 동작 구성
- 함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다.
  - 코드 작성을 마치면 코드 검토를 요청하기 전 자신이 작성한 코드를 비판적으로 다시 한번 살펴보는 것이 좋다
  - 함수를 한 문장으로 표현하기 어렵게 구현했다면 로직의 일부를 잘 명명된 헬퍼 함수로 분리하는 것을 고려하자

#### 클래스

단일 클래스의 이상적인 크기
- 줄 수(number of lines)
  - `한 클래스는 코드 300줄을 넘지 않아야 한다` 라는 가이드 라인이 존재
  - 300줄 이라는 것이 무조건 적절한 크기는 아니지만 300줄을 넘어갔을 때 **의심** 정도는 해봐야한다
- 응집력(cohesion)
  - 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 척도
  - 어떤 것들이 어떻게 결속되어 있는지 분류할 수 있는 방식이 존재
    - 순차적 응집력 : 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생. 원두를 갈아내는 과정의 산출물은 커피를 추출하는 과정에 투입. 갈고 -> 추출하는 것 사이에 서로 응집력이 있다~
    - 기능적 응집력 : 이것은 몇 가지 요소들이 모여서 하나의 일을 성취하는 데 기여할 떄 발생
      - 하나의 일이 무엇인가에 대한 정의는 매우 주관적일 수 있다
      - 필요하면 모두 함꼐 있어야한다
    - 관심사의 분리 : 시스템이 각각 별개의 문제를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙

응집력과 관심사의 분리에 대해 생각할 떄는 서로 관련된 여러 가지 사항을 하나의 사항으로 간주하는 것을 어느 수준에서 해야 유용할지 결정해야 한다.
- 이것은 매우 주관적일 수 있다
- 일반적인 것이 아닌 상황마다 `하나의 상황`으로 간주하는게 달라질 수 있다.


