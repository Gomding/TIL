1. 코드 라인수를 제한하는 것은 유용한 지침이다. 그러나 코드 라인수를 제한하여 얻고하는 것이 우선시 해야하지 코드 라인 수 가 우선시 되면 안된다.
    + 코드 라인 수를 제한한다는 것은 다음의 이점을 얻기 위함이다.
        - 이해하기 쉬운 코드 작성
        - 코드를 읽을 때 오해를 줄이기 위함
        - 실수로 작동이 안 되게 만들기가 어렵게하기 위함
    + 코드 라인 수를 제한한다는 것은 위의 이점을 얻기 위함이다.
    + 코드 라인 수에 목숨을 걸어서는 안되고 라인 수를 줄였을 때 위의 이점이 발생하는 지 고민해봐야한다.
    + `이해하기 어려운 코드 1줄` VS `이해하기 쉬운 코드 10줄` 무엇이 유지보수하기 좋은 코드가 될까?
2. 클래스의 생성자나 함수(메소드)가 너무 많은 매개변수(인자)를 가진다면 추상화 계층을 적절하게 정의하지 않았거나 모듈화되지 않았음을 의심해보자
3. 빌더 패턴은 명명된 매개변수 호출의 대안이 될 수 있을까? 완벽하지 않은 상태로 객체가 생성되는 위험이 존재한다.
    + 빌더 패턴으로 필요한만큼 필드를 초기화하지 않고 객체를 생성하는 오용 방법이 존재한다.
    + 즉 빌더 패턴도 장점만 있는것이 아님을 인지하자
4. 명명 함수 또는 함수를 분리하는 것은 어떤 이점이 있을까?
    + 특정 요구사항을 높은 수준에서 이해하기 위해서는 하위 수준의 개념 때문에 어려움을 겪도록 해서는 안된다.
    + ID 가 유효한지 확인하기 위해 비트를 확인하는 구현 세부사항을 `그대로 사용하는 것`과 `별도의 명명 함수로 분리하는 것`이 아래의 예제다
    
```java
// 함수 안에서 그대로 사용
List<UserId> getValidIds(List<UserId> ids) {
    return ids
        .filter(id -> id != 0)
        .filter(id -> countSetBits(id & 0x7FFF) % 2 == ((id & 0x0000) >> 15));
}

// 함수를 분리하여 사용
List<UserId> getValidIds(List<UserId> ids) {
    return ids
        .filter(id -> id != 0)
        .filter(isParityBitCorrect);
}

private boolean isParityBitCorrect(UserId id) {
    // UserId 가 유효한 비트인지 확인하는 로직
}
```
- .
    + 분리했을 때 이점은 유효한 비트인지 확인하는(하위 문제)의 복잡한 세부 사항은 몰라도 된다는 것이다.
    + getVaildIds 함수를 읽는 다른 개발자는 사용자 ID의 유효성 검사 시 0이 아닌 것과 비트를 검사한다는 큰 개념만 알고 넘어가도 된다는 것이다.
