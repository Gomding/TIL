# DataBase
* [Connection](#Connection)
* [Index](#Index)

## Connection
애플리케이션에서 데이터베이스에 접근하기위해 필요한 객체

## Connection Pool
Connection Pool은 Connection을 특정 공간(캐시 공간)에 미리 생성 해둔것을 의미합니다.   
클라이언트의 요청에 Thread에서 Connection Pool에 미리 생성해둔 Connection을 꺼내 쓰고 다시 반환하게 합니다.    

> 웹 서버(웹 애플리케이션 서버)에서 데이터베이스에 연결하기 위한 Connection 객체를 생성하는 비용은 작지 않습니다.   
> 클라이언트의 요청에 매번 Connection을 생성하는 것은 많은 비용을 발생시킬 수 있습니다.

## Connection Pool의 설정 값
* maxActive : 동시에 연결될 수 있는 최대 커넥션 개수
* maxIdle : Connection Pool에 반납할 때 최대로 유지할 커넥션 개수
* minIdle : 최소한으로 유지할 커넥션 개수
* initialSize : 최초로 getConnection() Method를 통해 커넥션 풀에 채워넣을 커넥션의 개수

**maxActive >= initialSize**   
동시에 연결될 수 있는 커넥션 개수(maxActive)는 최초로 생성할 커넥션 개수(initialSize)보다 크거나 같아야합니다. maxActive < initialSize도 설정은 가능하지만 논리적인 오류가 있는 설정입니다.   
**maxIdle > minIdle**   
최대로 유지할 커넥션 개수는(maxActive)는 최소로 유지할 커넥션 개수(minIdle)보다 커야합니다. maxIdle < minIdle도 설정은 가능하지만 논리적 오류가 있는 설정입니다.      
**maxActive = maxIdle**   
maxActive와 maxIdle 값은 같은것이 바람직합니다.   
maxActive = 10, maxIdle = 5 설정된 상태라고 가정합니다. 
현재 커넥션을 동시에 5개 사용중인 상황에서 추가로 1개의 커넥션 요청이 오면 maxActive = 10 이므로 커넥션을 추가로 생성하여 데이터베이스에 연결합니다. 
그 후 커넥션을 풀에 반납하면 현재 생성된 커넥션이 6개이므로 maxIdle = 5 설정값에 의해 커넥션이 닫힙니다.    
따라서 maxActive와 maxIdle설정이 같지않다면 매번 커넥션을 생성하고 닫는 비용이 발생할 수 있습니다.   

maxActive 값은 DBMS 설정과 애플리케이션 서버의 개수, Apache, Tomcat에서 동시에 처리할 수 있는 사용자(요청)의 수를 고려해서 설정해야합니다.   
DBMS가 수용할 수 있는 커넥션 개수를 확인하고 애플리케이션 서버 1대가 사용할 수 있는 적절한 커넥션 개수를 확인해서 설정해야합니다.
**사용자가 몰려서 커넥션을 많이 사용한다면 maxActive 값이 충분히 크지않다면 병목지점이 될 수 있습니다**

## maxWait
maxWait 설정값은 커넥션을 얻기 전 대기 시간입니다.
커넥션 풀 안에 커넥션이 없을 때 커넥션 반납을 대기하는 시간이며 기본값을 무한정입니다.   
maxWait 값을 설정하지 않고 기본값으로 무한정 대기하도록 해도 일반적으로는 문제가 안됩니다.   
하지만 사용자가 급증하거나 DBMS에 장애가 발생했다면 장애를 더욱 크게 확산할 수 있습니다.

적절한 maxWait 값을 설정하려면 TPS(transaction per seconds)와 Tomcat에서 처리 가능한 스레드 개수 등을 이해해야 합니다.

## TPS(Transaction per second)
사용자의 요청 하나에 쿼리 10개를 실행한다고 가정하고 각 쿼리는 50밀리초가 걸린다고 하면 10개의 쿼리는 500 밀리초가 걸립니다.   
다른 컴포넌트에 대한 처리시간은 생각하지않고 쿼리 처리시간만 생각했을 때 1요청에 걸리는 시간이 500밀리초라고 할 수 있습니다.   
만약 사용 가능한 커넥션이 5개라면 동시에 5개의 요청을 각각 500밀리초(0.5초)로 처리합니다. 즉, 1초 동안 10개의 요청을 처리할 수 있습니다.   
이때 성능 지수는 10TPS라고 할 수 있습니다.

## TPS와 커넥션 개수와의 관계
위에서 봤듯이 커넥션풀의 커넥션 개수가 5개라면 10TPS 이상의 성능을 낼 수 없습니다.   
커넥션풀에서 운영하는 커넥션이 5개이고 10개의 요청이라면 5개의 요청은 처리되지만 나머지 5개의 요청은 대기(wait)상태가 되어 여분의 커넥션이 생길때까지 maxWait 값만큼 기다립니다.   
여기서 성능을 향상시키는 가장 간단한 방법은 maxActive값을 늘리는것입니다.현재 maxActive = 5 이지만 maxActive = 10으로 늘리면 10TPS에서 20TPS로 늘어납니다.   

하지만 일반적으로 DBMS의 리소스는 다른 서비스와 공유해서 사용하는 경우가 많아서 무조건 커넥션 수를 늘릴 수는 없습니다.      
(DBMS도 수용 가능한 커넥션이 설정값으로 정해져있습니다.)   
따라서 커넥션 풀의 커넥션 수를 무조건 늘리는것보다 예상 접속자수와 실제 부하를 측정해서 최적의 값을 설정하는 것이 중요합니다.      
대기 시간(wait) 값을 잘 조절하는것이 커넥션 개수를 무한히 늘리지않고 최적의 시스템 환경을 구축하는데 중요한 역할을 합니다.    
maxWait 값을 어떻게 설정했는지가 일시적인 과부하 상태에서 드러나는 시스템의 전체적인 견고함을 결정짓습니다.   

## 적절한 maxWait 설정값 찾는 방법?
적당한 설정값을 찾기위해서는 Commons DBCP외에 Tomcat의 동작 방식을 고려해야합니다.   
Tomcat은 스레드 기반으로 동작해서 사용자의 요청을 처리합니다.   
Commons DBCP가 스레드 풀을 가지고 있는것처럼 Tomcat도 내부적으로 스레드 풀(wait set)을 가지고 있습니다.      
위에서 처럼 5개의 커넥션이 사용중이고 6번째 요청이 왔을 때 maxWait만큼 기다리는 주체는 Tomcat의 스레드입니다.   
maxWait = 10000 으로 설정하면 10초를 기다립니다. 즉, 처리량을 넘어서면 스레드가 다음 커넥션을 요청하기까지 10초동안 대기하는 것입니다. 
계속 요청이 들어오면 결국 Tomcat의 스레드 풀에 존재하는 모든 스레드를 사용하게 되고 Tomcat은 스레드가 없음을 알리는 오류를 출력하며 멈춥니다.   
> 심각: All threads (512) are currently busy, waiting. Increase maxThreads (512) or check the servlet status

10초가 지나서 커넥션을 획득하고 작업을 완료하여 성공적으로 응답을 보내도 대부분의 사용자는 이미 떠난 후입니다.(대부분의 사용자는 2~3초내에 응답이 없으면 요청 페이지를 떠납니다.)   
**즉, 사용자가 인내할 수 없는 시간을 넘는 maxWait값은 의미가 없습니다.**

반대로 maxWait값이 너무 작으면 커넥션이 없으면 자주 커넥션을 요청하게 될것이고 사용자는 오류메세지를 자주 보게 될 것입니다.   

그래서 maxWait는 사용자의 대기 가능한 시간, 애플리케이션의 특성과 주변의 다른 설정, 자원의 상황등을 고려해서 값을 정해야합니다.   
만약 사용자가 급증해서 maxWait안에 커넥션을 얻지 못하는 빈도가 증가한다면 maxWait값을 줄여서 시스템에서 사용하는 스레드 개수가 한계에 도달하지 않도록 방어할 수 있습니다.
(maxWait를 줄여서 실패한 스레드는 빠르게 반환하도록 유도하여 스레드 순환이 빠르게 돌도록 함)    
> 위와 같은 상황이 자주 발생한다면 Commons DBCP의 커넥션 풀 maxActive값과 Tomcat의 스레드 풀의 스레드 개수를 증가시키는 것을 고려해야합니다.

시스템 자원이 한도를 넘어섰다면 애플리케이션 서버의 확충(스케일 업 or 스케일 아웃)을 해야합니다.

## DBMS의 커넥션 최대 개수 설정하기
DBMS의 커넥션 최대 개수 설정 보는법
> show variables like '%max_connection%';   

DBMS에서 사용됐던 동시 최대 커넥션 숫자
> show status like '%max_used_connections%';

DBMS에서 수용 가능한 최대 커넥션 수를 설정하는 법 (대부분 default로 151이 설정됨) 
> set global max_connections = 500;

### 참고자료
* [Commons DBCP 이해하기 - NaverD2](https://d2.naver.com/helloworld/5102792)

---

## Index

## 인덱스

사전적 의미 : 색인, 어떤것을 뒤져서 찾아냄   
데이터 베이스에서의 인덱스 : 대용량 데이터 조회(READ)시 성능을 향상시켜주는 객체   
R(select)에서 성능향상 반면에 CUD(insert,update,delete)에서 성능 희생

### 인덱스의 저장공간

- 인덱스도 하나의 **객체**로 추가 저장공간이 필요(저장된 데이터의 10% 정도가 필요)
- InnoDB (MySQL)는 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 함
- **인덱스 역시 페이지 단위로 관리**
- MySQL 5.5 - 페이지는 16KB 로 크기가 고정
- MySQL 5.6 - 설정 옵션에따라 페이지 크기 제어가능 4KB, 8KB, 16KB (innodb_page_size 설정)
- MYSQL 5.7이후 - 32KB, 64KB크기를 지원(32KB, 64KB는 FOW_FORMAT= COMPRESSED 지원하지않음)

[https://sungwookkang.com/1213](https://sungwookkang.com/1213)

### 인덱스 키

- 인덱스로 지정한 컬럼의 크기(용량) ex. varchar(20)과 varchar(255)는 varchar(255)의 인덱스 키의 크기가 크다 라고 함
- 인덱스 키에는 제한 용량이 있음. 767byte / mariadb 10.5 dump 10.1버전에 복구하니까 인덱스 키 용량때문에 복구가 안된다함
- varchar(255)를 초과하면 위의 용량을 초과할 수 있음
- 페이지가 16KB일 때 인덱스 키가 50byte라면 (인덱스 키 외에 다른 용량도 고려해야하지만 여기선 제외)   
  16*1024 / 50   
  하나의 페이지에 약 327개의 데이터를 저장할 수 있음.   
- 인덱스 키가 100byte라면?
  하나의 페이지에 약 164개의 데이터를 저장할 수 있음.
→ 300개의 데이터 row를 읽을 때 50byte라면 1개의 페이지만 읽어도되지만 100byte면 2개의 페이지를 읽어야함   
→ 인덱스 키도 성능에 영향이 있다.

### Clustered Index

- 테이블당 1개만 존재
- PK제약조건으로 컬럼을 생성하면 자동 생성(PK가 없을 때 Unique 컬럼을 생성하면 Clustered Index 자동 생성)
    - Unique 컬럼을 먼저 생성하고 이후에 PK 컬럼을 새로 생성하면 PK컬럼에 Clustered Index 생성되고 Unique 컬럼은 Non-Clustered Index로 변경됨)
    - 48kb 히든 컬럼 → 별 기능없어서 PK 만들어주는게 좋음
- **인덱스에 데이터 페이지가 함께 존재**
- 리프 페이지 == 데이터 페이지(BTree)
- 데이터가 정렬된 상태여야 한다.
- CUD(추가, 수정,삭제)에서 데이터페이지를 정렬시켜야함 정렬된 상태

### Non-Clustered Index(Secondary Index)

- 다수가 존재 할 수 있음
- Unique 제약조건으로 컬럼을 생성하면 Non-Clustered Index가 자동 생성
- 인덱스에 데이터페이지가 존재하지 않음
    - 최종적으로 데이터페이지의 주소를 가리킴
- CUD(추가, 수정,삭제)에서 데이터페이지를 정렬하지 않아도됨 → 데이터가 정렬되지 않아도 된다.
- 데이터 페이지를 포함하지 않기 때문에 Clustered Index와 비교해서 조회 속도가 조금 떨어짐(Clustered Index와 비교해서 떨어지는것이 느린것이 아님)
- 데이터 페이지 정렬이 필요없으므로 CUD 성능이 Clustered Index와 비교시 부하가 적음

### 카디널리티(Cardinality)

인덱스의 효율성을 판단할 수 있는 수치 중 하나   
사전적 의미: 집합의 크기 또는 농도, 집합의 원소 개수에 대한 척도

[https://ko.wikipedia.org/wiki/집합의_크기](https://ko.wikipedia.org/wiki/%EC%A7%91%ED%95%A9%EC%9D%98_%ED%81%AC%EA%B8%B0)

데이터베이스에서는 해당 컬럼의 중복된 수치를 의미

좀 더 쉽게 이해하려면 카디널리티는 **'컬럼 내부의 유니크한 값의 개수'** 라고 할 수 있다.   
ex. 연필, 연필, 지우개, 볼펜, 형광펜, 형광펜, 형광펜 이렇게 데이터가 있으면 유니크한 값은 [연필, 지우개, 볼펜, 형관펜] 4개다 
- 카디널리티가 높다 == '중복도가 낮다'
    - 주민등록번호, 우편번호, 주소, 전화번호 등등은 중복도가 낮으므로 카디널리티가 높다.
- 카디널리티가 낮다 == '중복도가 높다'
    - 성별, 국가 의 경우 중복도가 높으므로 카디널리티가 낮다.

### 인덱스는 카디널리티가 높은 컬럼에 생성하면 효율이 상승한다.

- 성별의 경우 남,여 만 존재하기때문에 50%의 데이터만 필터링 → 나머지 50%에서 원하는 데이터를 다시 찾아야함
- 주민등록번호의 경우 인덱스를 통해 대부분의 데이터를 필터링 → 빠른 검색 가능

### 인덱스 자료구조

- HashTable
- B-Tree
- B+Tree

HashTable

- 우리가 흔히 아는 HashTable임
- 단일 조회에 특화됨 (where name = xxx) O(1)
- 범위 검색은 문제가 발생 (where age > 10)

B-Tree

- 데이터가 항상 정렬된 상태
- 가장 상단을 '루트 노드'
- 중간 노드를 '브랜치 노드'
- 마지막 노드를 '리프 노드'
- 같은 높이를 유지하기 때문에 어떤 데이터를 조회해도 비슷한 시간이 걸리는게 특징 = 균일성
- 브랜치 노드에서도 '키-값'의 형태로 있어서 데이터를 더 빨리 찾을 수 있다. → 키-값을 가지는 만큼 용량은 더 크므로 데이터의 숫자가 줄어듬 → 트리의 높이는 더 크다

![img_3.png](img_3.png)

B+Tree

- B-Tree와 구조는 똑같음
- 단 중간 노드(브랜치 노드)에서 '키-값'을 가지는게 아니라 **키만 가지고 있음**
- 중간 노드는 키만을 가지기 때문에 키-값을 가지는것보다 하나의 데이터가 차지하는 용량이 작음 → 더 많은 키를 가짐 → 트리의 높이가 낮아짐
- 리프 노드에서만 키-값을 가짐
- 같은 레벨의 노드끼리는 Doubly-LinkedList로 연결됨
- 자식 노드와는 Singly-LinkedList로 연결됨

![img_2.png](img_2.png)

[InnoDB](https://blog.jcole.us/innodb/)